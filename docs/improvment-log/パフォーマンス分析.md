# データベースパフォーマンス分析レポート

## 発見されたボトルネック

### 1. N+1クエリ問題

#### 問題箇所1: DashboardController - teacher()
```php
// 75行目: taughtSubjects()でクエリ実行
$subjectIds = $user->taughtSubjects()->pluck('id');

// 78-82行目: 各subject_idごとにクエリが実行される可能性
$totalStudents = Enrollment::whereIn('subject_id', $subjectIds)
    ->where('is_active', true)
    ->pluck('student_id')
    ->unique()  // メモリ上でユニーク化（非効率）
    ->count();
```

**問題点:**
- `pluck('student_id')->unique()->count()`は全レコードをメモリに読み込んでからユニーク化している
- `DISTINCT COUNT`を使うべき

#### 問題箇所2: DashboardController - student()
```php
// 155行目: enrolledSubjects()でクエリ実行
$subjectIds = $user->enrolledSubjects()->wherePivot('is_active', true)->pluck('id');

// 165-166行目: whereHasでサブクエリが実行される
$submissions = Submission::where('student_id', $user->id)
    ->whereHas('assignment', fn ($q) => $q->whereIn('subject_id', $subjectIds));
```

**問題点:**
- `whereHas`はサブクエリを生成し、パフォーマンスが悪い
- JOINを使うか、事前にassignment_idを取得すべき

#### 問題箇所3: SubmissionController - index()
```php
// 25行目: taughtSubjects()でクエリ実行
$subjectIds = $request->user()->taughtSubjects()->pluck('id');

// 26行目: whereHasでサブクエリが実行される
$query->whereHas('assignment', fn ($q) => $q->whereIn('subject_id', $subjectIds));
```

**問題点:**
- 同じパターンが繰り返されている
- JOINを使うべき

### 2. 非効率なクエリパターン

#### 問題箇所4: DashboardController - teacher() - totalStudents
```php
// 78-82行目
$totalStudents = Enrollment::whereIn('subject_id', $subjectIds)
    ->where('is_active', true)
    ->pluck('student_id')  // 全レコードを取得
    ->unique()             // メモリ上でユニーク化
    ->count();             // カウント
```

**改善案:**
```php
$totalStudents = Enrollment::whereIn('subject_id', $subjectIds)
    ->where('is_active', true)
    ->distinct('student_id')
    ->count('student_id');
```

#### 問題箇所5: DashboardController - getSubmissionStats()
```php
// 227-230行目: 複数のcount()クエリが個別に実行される
$total = Submission::count();
$submitted = Submission::whereIn('status', ['submitted', 'graded', 'resubmit_required', 'resubmitted'])->count();
$notSubmitted = $total - $submitted;
$overdue = Submission::overdue()->count();
```

**問題点:**
- 4つのクエリが個別に実行される
- 1つのクエリで集約すべき

**改善案:**
```php
$stats = Submission::selectRaw('
    COUNT(*) as total,
    SUM(CASE WHEN status IN (\'submitted\', \'graded\', \'resubmit_required\', \'resubmitted\') THEN 1 ELSE 0 END) as submitted,
    SUM(CASE WHEN is_overdue = true THEN 1 ELSE 0 END) as overdue
')->first();
```

### 3. リレーションのEager Loading不足

#### 問題箇所6: SubmissionController - bulkCreate()
```php
// 250行目: subject.studentsをロードしているが、N+1が発生する可能性
$assignment = Assignment::with('subject.students')->findOrFail($assignmentId);

// 256-258行目: ループ内でクエリが実行される
foreach ($assignment->subject->students as $student) {
    $existing = Submission::where('assignment_id', $assignmentId)
        ->where('student_id', $student->id)
        ->exists();
```

**問題点:**
- ループ内でクエリが実行される（N+1）
- 一括で存在チェックすべき

### 4. インデックスの不足

現在のインデックス状況：
- ✅ `submissions`: 基本的なインデックスは存在（student_id, status, submitted_at, graded_at, is_overdue）
- ✅ `enrollments`: 基本的なインデックスは存在（student_id, is_active）
- ✅ `assignments`: 基本的なインデックスは存在（subject_id, deadline, published_at, is_active）

**不足している複合インデックス:**

1. **submissions テーブル**
   - `student_id` + `status` の複合インデックス（学生の提出状況一覧で使用）
   - `assignment_id` + `status` の複合インデックス（課題ごとの提出状況で使用）

2. **enrollments テーブル**
   - `subject_id` + `is_active` の複合インデックス（科目ごとのアクティブ学生数で使用）

3. **assignments テーブル**
   - `subject_id` + `is_active` + `published_at` の複合インデックス（ダッシュボードで使用）
   - `subject_id` + `deadline` の複合インデックス（締切順ソートで使用）

## 推奨される修正

### 優先度: 高

1. **DashboardController::teacher() - totalStudents の改善**
   - `pluck()->unique()->count()` → `distinct()->count()`

2. **DashboardController::getSubmissionStats() の改善**
   - 複数クエリ → 1つの集約クエリ

3. **whereHas の使用を減らす**
   - JOINまたは事前フィルタリングに変更

### 優先度: 中

4. **SubmissionController::bulkCreate() の改善**
   - ループ内クエリを一括処理に変更

5. **必要なインデックスの追加**
   - マイグレーションファイルで確認・追加

### 優先度: 低

6. **クエリ結果のキャッシュ**
   - 頻繁にアクセスされるデータのキャッシュ検討

## パフォーマンス測定の推奨

以下のツールを使用して実際のボトルネックを特定することを推奨します：

1. **Laravel Debugbar** - クエリ数と実行時間の可視化
2. **Laravel Telescope** - 詳細なクエリ分析
3. **EXPLAIN ANALYZE** - PostgreSQLのクエリプラン分析
